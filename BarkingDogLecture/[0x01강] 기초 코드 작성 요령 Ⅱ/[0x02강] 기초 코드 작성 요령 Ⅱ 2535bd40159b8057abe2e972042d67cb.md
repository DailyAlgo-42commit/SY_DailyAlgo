# [0x02강] 기초 코드 작성 요령 Ⅱ

상태: 완료

### 0x00 STL과 함수 인자

- **코드 출력 예상 ::** 함수의 인자로 int / int 배열 / 구조체를 실어보내서 값을 바꿨을 때, 원본의 값이 바뀌는지를 물어보는 문제
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image.png)
    
    1. int를 함수 인자로 보내면 값이 복사되어 넘어감. 즉, 함수에서 값을 바꾸더라도 main의 변수 t에는 **영향을 주지 않음
    2. func에 int배열 arr를 인자로 주는게 arr의 주소를 넘겨주는 것이니 arr[0]을 func 함수에서 바꾸면 원본의 값도 자연스럽게 바뀜
    3. 구조체의 경우, int랑 비슷하게 그냥 값이 다 복사되기 때문에 func 함수에서 값을 바꿔도 원본에는 영향을 주지 않음. 
- 두 변수를 **swap**
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%201.png)
    
    1. swap1 함수는 제대로 동작 X → 원본 2개를 바꾸고싶은데 복사된 2개를 바꾸는건 의미 없음
    2. swap2 함수는 포인트를 보내서 두 변수의 값을 바꿈
    3. swap3 함수는 함수 인자인 a와 b의 type이 int가 아니고, int 뒤에 &가 붙어있음 ⇒ a와 b는 int reference
    이처럼 a와 b를 참조자로 만들면 함수 내의 코드에서는 그냥 int를 쓰듯 tmp에 a를 대입하고, a에 b를 대입 ⇒ 원본을 바
- STL (Standard Template Library)
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%202.png)
    
    - C++에서는 배열을 선언할 때 크기를 명시, 무조건 해당 크기 안에서만 사용 해야함. but, vector는 일종의 가변배열로, 크기를 마음대로 늘렸다 줄였다 할 수 있음
    - vector는 vector 헤더에 선언되어 있음
    - 01번째 줄 : type이 int이고 0을 초기화된 100칸짜리 가변배열 v가 선언됨
    02, 03번째 줄처럼 일반적일 배열을 쓰듯, 인덱스에 접근해서 값을 바꿀 수 있음
- STL을 함수 인자로 넘길 때
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%203.png)
    
    100칸짜리 0으로 초기화된 vector v 선언 → func1 호출
    
    func1에서는 v[10]을 7로 바꿈
    
    but, v[10]을 출력하면 값은 **0**
    
    ⇒ STL도 구조체랑 비슷하게 함수 인자로 실어 보내면 복사본을 만들어서 보내기 때문에 func1 함수에서 바꾼건 원본에 영향을 주지 않음
    
    ** 그냥 STL을 쌩으로 함수 인자에 넣으면 복사해서 보낸다는 걸 꼭 유의해야함!!
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/a6b9f0aa-276c-44b2-a99e-c5705b41b158.png)
    
    두 vector를 인자로 넘겨받아 idx번째 원소의 값을 비교한 결과를 반환하는 함수. 두 vector의 크기가 N이라고 할 때, 이 함수의 시간복잡도 ⇒ **O(N)**
    v1, v2를 인자로 실어서 보낼 때 원본으로부터 복사본을 만드는 비용 고려 ⇒ v1, v2의 크기가 N 이므로 N개의 원소를 하나하나 복사하는 과정은 O(N)
    
    ![idx번째 원소의 값만 비교하고 싶을데 매번 vector를 복사하는건 비효율. 이때 참조자 이용 ⇒ cmp2](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/5c8e9f31-da1e-4bc1-896d-f686563584ef.png)
    
    idx번째 원소의 값만 비교하고 싶을데 매번 vector를 복사하는건 비효율. 이때 참조자 이용 ⇒ cmp2
    
    cmp2 함수에서는 v1, v2의 type을 vector의 reference로 만들어 cmp2가 호출될 때 복사본을 따로 만들어내지 않고 참조 대상의 주소 정보만 넘어가기 때문에 시간 복잡도는 의도한대로 **O(1)** 이 됨
    
    `**이 내용들이 헷갈리면 코드의 시간복잡도를 착각해버리거나 함수에서 복사본의 값을 바꿔서 원본은 변함이 없는데 원본이 바뀐다고 잘못 생각해서 분명 답이 이상하게 나오는데 원인을 못찾는다거나 할 수 있기 때문에 참조자와 함수 인자 부분은 기억해야함**`
    

### 0x01 표준 입출력

![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%204.png)

C - scanf/printf 로 입력과 출력 처리
C++ - cin/cout 으로 입력과 출력 처리 (기능 차이는 없어서 scanf/printf 사용해도 무관)
but, scanf/printf 는 C++ string 처리를 할 수 없음. C에서는 char*로 문자열을 다루는데, char*보다 C++ string이 월등하게 편함. 

⇒ scanf/printf 쓰면서도 C++ string 활용하고 싶다면, char*로  입력을 받고 string으로 형 변환을 해서, 원하는 작업을 다 끝낸 후에 c_str() 메소드를 이용해 출력하면 됨. 

![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%205.png)

scanf나 cin을 쓸 때 주의할 점 :  공백을 포함한 문자열을 입력받을 때, 둘다 공백 앞까지만 입력을 받음. 
**⇒ 공백을 포함한 문자열을 받아야 할 때 단순히 scanf나 cin을 쓰면 안됨!**

[해결책]

1. scanf에서 줄바꿈(\n)이 나오기 전까지 입력을 받는다는걸 명시(외우기 힘들듯)
2. gets 함수 사용(보안상의 이유로 C++14 이상에서는 제거됨)
3. getline 이용 (제일 깔끔한 방식이지만, 이건 type이 C++string이어야함)
- cin/cout 사용시  주의할점
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/5a9e579e-24d0-4416-8071-4d6cf35a3e30.png)
    
    - scanf/printf와 다르게 cin/cout은 입출력으로 인한 시간초과를 막기 위해서 ios::sync_with_stdio(0), cin.tie(0)이라는 두 명령을 실행시켜야함. 이걸 안해두면 입/출력의 양이 많을 때 시간초과가 날 수 있음.
    - 기본적으로 scanf/printf 등에서 쓰는 C stream과 cin/cout 등에서 쓰는 C++ stream은 분리 되어있어. but, 지금 코드처럼 printf와 cout을 번갈아하며 사용하는 상황을 생각해보면 사용자 입장에서는 그냥 11111, 22222, 33333이 차례대로 나오는게 정상
    - 코드의 흐름과 실제 출력이 동일하기 위해서 기본적으로 프로그램에서는 C++ stream과 C stream을 동기화함.  but,  C++ stream만 쓸거면 굳이 두 stream을 동기화하고 있을 필요가 없음.
    - C++ stream만 쓸거면 동기화를 끊어버려서 프로그램 수행 시간에서 이득을 챙길 수 있고, 동기화를 끊는 명령이 **sync_with_stdio(0)** (엄밀히 말해 인자가 bool type이라 **sync_with_stdio(false)**가 맞음)
    - 동기화를 끊었으면 절대 cout과 printf를 섞어쓰면 안됨. 섞어쓰면 지금 코드 출력 결과처럼 순서가 꼬임
    - 두 번째 명령인 cin.tie(0)을 이해하려면 버퍼라는 개념을 이해해야함.
- 버퍼(buffer)
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%206.png)
    
    - 화면에 아무 글자나 출력을 하는걸 생각해보면, 별 생각 없이 cout으로 출력을 찍지만 사실은 한 글자 한 글자가 바로 화면에 보이는게 아님. ⇒ 출력 버퍼라는 곳에 문자가 임시로 저장되었다가 버퍼가 비워지면서 화면에 보임
    - 출력에서 버퍼가 있는 것처럼, 입력에서도 버퍼가 있어서 키보드로 받은 입력을 바로바로 넘겨주지 않고 버퍼에서 어느 정도 모았다가 줌.
    
    ![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%207.png)
    
    입력과 출력이 번갈아 나오고, 그게 한 화면에서 다 보여질 경우에는 버퍼의 존재로 인해 순서가 꼬여버릴 수 있음.
    
    위 코드를 보면, 3번에 걸쳐 두 수를 입력받고 합을 출력하는데, 우리는 당연히 순서에 맞게 콘솔에 나타나기를 원함. but, 예를 들어 6번 줄에서 “118\n” 출력을 하라고 했을 때, 바로 출력이 되지 않고 버퍼에 들어갔다가 “2 5”를 입력한 후에야 출력이 되면 순서가 꼬임.
    
    ⇒ 이런 현상을 막기 위해 기본적으로는 cin 명령을 수행하기 전에 cout 버퍼를 비워줌. 버퍼를 비우면 자연스럽게 “2 5” 입력이 들어오기 전에 118이 출력될거고, “94 542” 입력이 들어오기 전에 “7”이 출력되어서 순서가 꼬이지 않음. (온라인 저지 사이트에서는 채점을 할 때 그냥 출력 글자만 확인함. 그렇기 때문에 콘솔 창에서 입력 글자와 출력 글자 사이에 순서가 꼬인다고 해도 채점에 아무 영향을 주지 않고, 두 경우 모두 다 정답 처리 됨.)
    
    ⇒ 굳이 cin 명령을 수행하기 전에 cout 버퍼를 비울 필요 없으니까 cin 명령을 수행하기 전에 cout 버퍼를 비우지 않도록하는 코드
    = cin.tie(nullptr)
    ** sync_with_studio를 쓴 이후로는 무조건 cin/cout만 쓰고 printf/scanf를 쓰면 안된다는 것도 꼭 기억해야함. **
    
- endl 쓰지마!!
    
    endl은 개행문자("\n")를 출력하고 출력 버퍼를 비우라는 명령. 앞에서 언급했듯, 어차피 저지는 프로그램이 종료될 때 출력이 어떻게 됐는지만 보고 채점을 진행하니까 중간 중간 버퍼를 비우라고 명령을 줄 필요가 전혀 없음. 줄바꿈이 필요하면 endl 말고 개행문자 출력하면 됨. 
    

### 0x02 코드 작성 팁

![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/image%208.png)

코딩테스트에서는 내가 헷갈리지 않는 범위 안에서 어떻게든 타이핑을 아끼는게 최고. 코딩테스트의 목표는 남이 알아볼 수 있는 클린코드를 작성하는게 아. 어떻게든 제한된 시간 안에 정답을 받아야함. 

⇒ 코드를 책에 예제로 실어도 될 정도로 깔끔하게 만들기 위해 노력하기 보다는, 좀 더럽더라도 내가 빠르게 짤 수 있는 방식으로 빠르게 구현하는게 훨씬 더 중요.

![image.png](%5B0x02%EA%B0%95%5D%20%EA%B8%B0%EC%B4%88%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%20%EC%9A%94%EB%A0%B9%20%E2%85%A1%202535bd40159b8057abe2e972042d67cb/de268ebb-b271-4885-9277-ffd6412fd992.png)

→ 3 다음에 공백 1개가 추가로 출력됐지만, 아무 문제 없이 정답 처리됨.